{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction to the GGMP\n\n\nThe Generic Gameserver Messaging Protocol, or GGMP, is a messaging protocol that sits atop UDP. The protocol is designed\nfrom the ground up to send Messages between game servers and clients. Messages are designed to contain easily decodable\ninformation about updates to game state.\n\n\nGoals for the proposed protocol are:\n\n\n\n\nLightweight: Exactly as much data as needed and no more.\n\n\nSelf-contained: Transmit as much information about an Action in one Message as possible\n\n\nEfficient: Small packet size, in pure bytes for ease of server and client-side processing.\n\n\nResilient: A lost or malformed packet will be handled by the server, and is not breaking.\n\n\nFlexible: Usable for anything from a simple command-line game to a full-blown RTS.\n\n\n\n\nNon-goals are:\n\n\n\n\nData integrity: Following a common design pattern among games, dropped packets are not game breaking.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction-to-the-ggmp", 
            "text": "The Generic Gameserver Messaging Protocol, or GGMP, is a messaging protocol that sits atop UDP. The protocol is designed\nfrom the ground up to send Messages between game servers and clients. Messages are designed to contain easily decodable\ninformation about updates to game state.  Goals for the proposed protocol are:   Lightweight: Exactly as much data as needed and no more.  Self-contained: Transmit as much information about an Action in one Message as possible  Efficient: Small packet size, in pure bytes for ease of server and client-side processing.  Resilient: A lost or malformed packet will be handled by the server, and is not breaking.  Flexible: Usable for anything from a simple command-line game to a full-blown RTS.   Non-goals are:   Data integrity: Following a common design pattern among games, dropped packets are not game breaking.", 
            "title": "Introduction to the GGMP"
        }, 
        {
            "location": "/components/", 
            "text": "GGMP Message Components\n\n\nGGMP Messages are comprised of \nComponents\n, which describe the Message format itself, as well as Client ID, Actors and\n Actions, and so on. Not every Component is included in every Message; the Header dictates the \nMessage Type\n, which \nfurther dictates the Components and structure of the Message.\n\n\nHEAD: Header\n\n\n\n\nSize: 1 byte\n\n\nAcceptable Values: 0x00 - 0xFF\n\n\n\n\nThe Header dictates the Message Type. The following Message Types are currently available in GGMP. For information on \ntheir structure, see \nMessage Types\n.\n\n\n\n\n\n\n\n\nHeader Value\n\n\nType\n\n\nDescription\n\n\nSize (bytes)\n\n\n\n\n\n\n\n\n\n\n0x00\n\n\nAction\n\n\nLong-form Action with Conditions, Message IDs\n\n\n24\n\n\n\n\n\n\n0x01\n\n\nActionNoAck\n\n\nLong-form Action as above, but don't require ACK\n\n\n24\n\n\n\n\n\n\n0x02\n\n\nActionShort\n\n\nLightweight Action with reduced value ranges\n\n\n8\n\n\n\n\n\n\n0x04\n\n\nActionExtended\n\n\nAction with additional data contained in a following message\n\n\n24\n\n\n\n\n\n\n0x0E\n\n\nData\n\n\nData corresponding to a previous message\n\n\n?\n\n\n\n\n\n\n0x12\n\n\nDataEnd\n\n\nFinal Data corresponding to a previous message\n\n\n?\n\n\n\n\n\n\n0x14\n\n\nActionData\n\n\nAction with Data and add'l Data to follow\n\n\n?\n\n\n\n\n\n\n0x16\n\n\nActionDataEnd\n\n\nAction with arbitrary Data\n\n\n?\n\n\n\n\n\n\n0xFE\n\n\nClient Assign\n\n\nUsed by server to assign a Client ID to a connected Client\n\n\n?\n\n\n\n\n\n\n0xFF\n\n\nAck\n\n\nAcknowledge a previous message which has requested it\n\n\n8\n\n\n\n\n\n\n\n\nAn important note: Any even-numbered Message Type in the range 0x00 to 0xEE can opt not to \nrequire an ACK by increasing the value of the Header by 0x01. In the table above, this property is explicitly written \nfor the Action message type, however this property is implemented for all Message Types in the above range, and is \nsimply implied in much of this documentation.\n\n\nCL: Client ID\n\n\n\n\nSize: 3 bytes \n\n\nAcceptable Values: 0x000001 - 0xFFFFFF for Clients, 0x00 for Server\n\n\n\n\nThe Client ID is a value assigned to a Client by the Game Server. It is useful for tracking origin of a Message as it is\nprocessed by the Game Server. Additionally, it provides a way, if desired, to delineate Actors based on Client. A game \ncould choose to have all actors 'owned' by a particular client, providing a number of benefits, not the least of which \nis an additional layer of security against message spoofing.\n\n\nThe Client ID 0x00 is reserved for the Game Server itself. Further Client IDs should begin at 0x01 and increment by 0x01\nfor each new client assigned.\n\n\nMID: Message ID\n\n\n\n\nSize: 4 bytes\n\n\nAcceptable Values: 0x00000000 - 0xFFFFFFFFF\n\n\n\n\nThe Message ID is a Component that can assist with certain features in advanced GGMP implementations. For \nexample, \nAck\n and \nData\n messages use Message IDs to refer to previous messages. \nAdditionally, Message IDs can be used to estimate packet loss, ensure correct ordering of packets, etc.\n\n\nMessage IDs should be unique per client per message. That is to say: no one Client should send multiple Messages with \nthe same ID. However, Messages from \ndifferent\n clients can share IDs, and in fact this is expected.\n\n\nEach client should begin counting their Messages at 0x00000000 and increment them by 0x01 with every message sent.\n\n\nAR: Actor\n\n\n\n\nSize: 4 bytes\n\n\nAcceptable Values: 0x00000000 - 0xFFFFFFFF\n\n\n\n\nThe Actor is any game entity which takes an Action. The assignment, interpretation, and implementation of these actors \nis left entirely to the programmer. Actors can correspond to individual players, units controlled by players, the game \nstate itself, etc.\n\n\nIt is recommended, though not required, that Actor 0x00 be reserved for the keeper of the game state.\n\n\nAN: Action\n\n\n\n\nSize: 4 bytes\n\n\nAcceptable Values: 0x00000000 - 0xFFFFFFFF\n\n\n\n\nAn Action is a game event taken by an Actor. Like the definition of an Actor, Actions are left intentionally vague. They\ncan communicate game state (though this is discouraged) or game actions. \n\n\nAC1, AC2: Action Condition 1 and 2\n\n\n\n\nSize: 4 bytes each\n\n\nAcceptable Values: 0x00000000 - 0xFFFFFFFF\n\n\nOptional\n\n\n\n\nAction Conditions act as parameters for Actions. They are used to attach data an Action. Their use is optional. If an \nAction does not require the use of Conditions, the byte ranges for those conditions should be cleared to 0x00.\n\n\nIf the data associated with an Action would exceed 8 bytes, use a message type that uses the Data component.\n\n\nDAT : Data\n\n\n\n\nSize: User-defined\n\n\nAcceptable Values: User-defined\n\n\n\n\nData is used for the transfer of Data which is either too large for an \nAction\n Message, or which can be sent separately.\nMessage Types implementing Data include: \nArbData\n, \nData\n, \nDataEnd\n, etc. \n\n\nSIZ: Data Size\n\n\n\n\nSize: 1 byte\n\n\nAcceptable Values: 0x00 - 0xFF\n\n\n\n\nData Size specifies the length, in bytes, of Action Data attached to a \nData\n or \nDataEnd\n Message.\n\n\nTYP: Data Type\n\n\n\n\nSize: 1 byte\n\n\nAcceptable Values: 0x00 - 0x06 \n\n\n\n\nData Type is used in \nArbData\n (and, in the future, \nData\n and similar Messages) to indicate to the recipient how to decode\nthe related Data Component. Available types are:\n\n\n\n\n\n\n\n\nValue\n\n\nType\n\n\nDetail\n\n\n\n\n\n\n\n\n\n\n0x00\n\n\nUINT32\n\n\nUnsigned 32-bit Integer\n\n\n\n\n\n\n0x01\n\n\nINT32\n\n\nSigned 32-bit Integer\n\n\n\n\n\n\n0x02\n\n\nUINT64\n\n\nUnsigned 64-bit Integer\n\n\n\n\n\n\n0x03\n\n\nINT64\n\n\nSigned 64-bit Integer\n\n\n\n\n\n\n0x04\n\n\nDOUBLE\n\n\nIEEE 754 Double-precision floating point\n\n\n\n\n\n\n0x05\n\n\nASCII\n\n\nASCII String, NOT null-terminated\n\n\n\n\n\n\n0x06\n\n\nUTF8\n\n\nUTF-8 String\n\n\n\n\n\n\n\n\nAt this time, custom types are not permitted. If an implementation calls for a custom type, those types should begin at \n0xFF, to allow for future expansion of this Component.\n\n\nNUM: Data Components Count\n\n\n\n\nSize: 1 byte\n\n\nAcceptable Values: 0x01 - 0x08\n\n\n\n\nData Components Count is used in \nArbData\n to signify how many Data components are included in the message. This allows\nfor the recipient to more easily process an incoming \nArbData\n message.\n\n\nPMSG: Parent Message\n\n\n\n\nSize: 4 bytes\n\n\nAcceptable Values: 0x00000000 - 0xFFFFFFFF\n\n\n\n\nParent Message is used by \nData\n/\nDataEnd\n or \nAck\n Messages to express the Message ID with which they are associated. A \n\nData\n/\nDataEnd\n Message must additionally have a Message ID of its own.", 
            "title": "Components"
        }, 
        {
            "location": "/components/#ggmp-message-components", 
            "text": "GGMP Messages are comprised of  Components , which describe the Message format itself, as well as Client ID, Actors and\n Actions, and so on. Not every Component is included in every Message; the Header dictates the  Message Type , which \nfurther dictates the Components and structure of the Message.", 
            "title": "GGMP Message Components"
        }, 
        {
            "location": "/components/#head-header", 
            "text": "Size: 1 byte  Acceptable Values: 0x00 - 0xFF   The Header dictates the Message Type. The following Message Types are currently available in GGMP. For information on \ntheir structure, see  Message Types .     Header Value  Type  Description  Size (bytes)      0x00  Action  Long-form Action with Conditions, Message IDs  24    0x01  ActionNoAck  Long-form Action as above, but don't require ACK  24    0x02  ActionShort  Lightweight Action with reduced value ranges  8    0x04  ActionExtended  Action with additional data contained in a following message  24    0x0E  Data  Data corresponding to a previous message  ?    0x12  DataEnd  Final Data corresponding to a previous message  ?    0x14  ActionData  Action with Data and add'l Data to follow  ?    0x16  ActionDataEnd  Action with arbitrary Data  ?    0xFE  Client Assign  Used by server to assign a Client ID to a connected Client  ?    0xFF  Ack  Acknowledge a previous message which has requested it  8     An important note: Any even-numbered Message Type in the range 0x00 to 0xEE can opt not to \nrequire an ACK by increasing the value of the Header by 0x01. In the table above, this property is explicitly written \nfor the Action message type, however this property is implemented for all Message Types in the above range, and is \nsimply implied in much of this documentation.", 
            "title": "HEAD: Header"
        }, 
        {
            "location": "/components/#cl-client-id", 
            "text": "Size: 3 bytes   Acceptable Values: 0x000001 - 0xFFFFFF for Clients, 0x00 for Server   The Client ID is a value assigned to a Client by the Game Server. It is useful for tracking origin of a Message as it is\nprocessed by the Game Server. Additionally, it provides a way, if desired, to delineate Actors based on Client. A game \ncould choose to have all actors 'owned' by a particular client, providing a number of benefits, not the least of which \nis an additional layer of security against message spoofing.  The Client ID 0x00 is reserved for the Game Server itself. Further Client IDs should begin at 0x01 and increment by 0x01\nfor each new client assigned.", 
            "title": "CL: Client ID"
        }, 
        {
            "location": "/components/#mid-message-id", 
            "text": "Size: 4 bytes  Acceptable Values: 0x00000000 - 0xFFFFFFFFF   The Message ID is a Component that can assist with certain features in advanced GGMP implementations. For \nexample,  Ack  and  Data  messages use Message IDs to refer to previous messages. \nAdditionally, Message IDs can be used to estimate packet loss, ensure correct ordering of packets, etc.  Message IDs should be unique per client per message. That is to say: no one Client should send multiple Messages with \nthe same ID. However, Messages from  different  clients can share IDs, and in fact this is expected.  Each client should begin counting their Messages at 0x00000000 and increment them by 0x01 with every message sent.", 
            "title": "MID: Message ID"
        }, 
        {
            "location": "/components/#ar-actor", 
            "text": "Size: 4 bytes  Acceptable Values: 0x00000000 - 0xFFFFFFFF   The Actor is any game entity which takes an Action. The assignment, interpretation, and implementation of these actors \nis left entirely to the programmer. Actors can correspond to individual players, units controlled by players, the game \nstate itself, etc.  It is recommended, though not required, that Actor 0x00 be reserved for the keeper of the game state.", 
            "title": "AR: Actor"
        }, 
        {
            "location": "/components/#an-action", 
            "text": "Size: 4 bytes  Acceptable Values: 0x00000000 - 0xFFFFFFFF   An Action is a game event taken by an Actor. Like the definition of an Actor, Actions are left intentionally vague. They\ncan communicate game state (though this is discouraged) or game actions.", 
            "title": "AN: Action"
        }, 
        {
            "location": "/components/#ac1-ac2-action-condition-1-and-2", 
            "text": "Size: 4 bytes each  Acceptable Values: 0x00000000 - 0xFFFFFFFF  Optional   Action Conditions act as parameters for Actions. They are used to attach data an Action. Their use is optional. If an \nAction does not require the use of Conditions, the byte ranges for those conditions should be cleared to 0x00.  If the data associated with an Action would exceed 8 bytes, use a message type that uses the Data component.", 
            "title": "AC1, AC2: Action Condition 1 and 2"
        }, 
        {
            "location": "/components/#dat-data", 
            "text": "Size: User-defined  Acceptable Values: User-defined   Data is used for the transfer of Data which is either too large for an  Action  Message, or which can be sent separately.\nMessage Types implementing Data include:  ArbData ,  Data ,  DataEnd , etc.", 
            "title": "DAT : Data"
        }, 
        {
            "location": "/components/#siz-data-size", 
            "text": "Size: 1 byte  Acceptable Values: 0x00 - 0xFF   Data Size specifies the length, in bytes, of Action Data attached to a  Data  or  DataEnd  Message.", 
            "title": "SIZ: Data Size"
        }, 
        {
            "location": "/components/#typ-data-type", 
            "text": "Size: 1 byte  Acceptable Values: 0x00 - 0x06    Data Type is used in  ArbData  (and, in the future,  Data  and similar Messages) to indicate to the recipient how to decode\nthe related Data Component. Available types are:     Value  Type  Detail      0x00  UINT32  Unsigned 32-bit Integer    0x01  INT32  Signed 32-bit Integer    0x02  UINT64  Unsigned 64-bit Integer    0x03  INT64  Signed 64-bit Integer    0x04  DOUBLE  IEEE 754 Double-precision floating point    0x05  ASCII  ASCII String, NOT null-terminated    0x06  UTF8  UTF-8 String     At this time, custom types are not permitted. If an implementation calls for a custom type, those types should begin at \n0xFF, to allow for future expansion of this Component.", 
            "title": "TYP: Data Type"
        }, 
        {
            "location": "/components/#num-data-components-count", 
            "text": "Size: 1 byte  Acceptable Values: 0x01 - 0x08   Data Components Count is used in  ArbData  to signify how many Data components are included in the message. This allows\nfor the recipient to more easily process an incoming  ArbData  message.", 
            "title": "NUM: Data Components Count"
        }, 
        {
            "location": "/components/#pmsg-parent-message", 
            "text": "Size: 4 bytes  Acceptable Values: 0x00000000 - 0xFFFFFFFF   Parent Message is used by  Data / DataEnd  or  Ack  Messages to express the Message ID with which they are associated. A  Data / DataEnd  Message must additionally have a Message ID of its own.", 
            "title": "PMSG: Parent Message"
        }, 
        {
            "location": "/message-types/", 
            "text": "Message Types\n\n\nGGMP provides a number of various \nMessage Types\n for a variety of use cases related to game client and server\n programming. Many of these types are designed to be as flexible as possible. GGMP stands for \nGeneric\n Gameserver \n Messaging Protocol, after all. It's up to you, the game developer to determine what Actor 45 is, what Actions he can \n take, and what to do with all that information. Is it critical that the server receive your data? Use an \nAck\n variant\n of your Message and your client library will ensure it's received. Don't need support for over 4 billion actors? Use \n \nActionShort\n Messages for your game instead. \n\n\nReq-Ack vs. No-Ack\n\n\nMessage Types ranging from 0x00 to 0xEF have both Req-Ack and No-Ack variants. For the sake of conciseness and brevity, only\ntheir Req-Ack variants are listed here. However, since Req-Ack vs. No-Ack doesn't change the structure of a message, converting\nbetween them is easy: Simply increment the Header by 0x01, and you have the No-Ack version of that message. For example, the \nHeader value for \nAction, Req-Ack\n is 0x00. The corresponding Header for \nAction, No-Ack\n is 0x01. \n\n\nIn this documentation, we will explicitly denote \nNo-Ack\n when referring to such a variant. If no variant is specified, \nit can safely be inferred that the Message in question is \nReq-Ack\n.\n\n\n0x00 - 0xEF: Game State Message Types\n\n\nThese Message Types make up the core of communication over GGMP. \n\n\n0x00 - Action\n\n\nThe bread-and-butter message of GGMP, a game Action with Actors and Conditions.\n\n\nBytes\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n6\n\n\n7\n\n\n8\n\n\n9\n\n\n10\n\n\n11\n\n\n12\n\n\n13\n\n\n14\n\n\n15\n\n\n16\n\n\n17\n\n\n18\n\n\n19\n\n\n20\n\n\n21\n\n\n22\n\n\n23\n\n\n\n\n\n\n\n\n\n\nHEAD\n\n\nCL\n\n\nCL\n\n\nCL\n\n\nMID\n\n\nMID\n\n\nMID\n\n\nMID\n\n\nAR\n\n\nAR\n\n\nAR\n\n\nAR\n\n\nAN\n\n\nAN\n\n\nAN\n\n\nAN\n\n\nAC1\n\n\nAC1\n\n\nAC1\n\n\nAC1\n\n\nAC2\n\n\nAC2\n\n\nAC2\n\n\nAC2\n\n\n\n\n\n\n\n\nComponents\n\n\n\n\nHead \n\n\nClient ID \n\n\nMessage ID \n\n\nActor ID \n\n\nAction ID \n\n\nAction Condition 1 \n\n\nAction Condition 2 \n\n\n\n\n0x02 - ActionShort\n\n\nA micro-sized version of an Action. Ideal for demos, tutorials, and ultra-lightweight games.\n\n\nBytes\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n6\n\n\n7\n\n\n\n\n\n\n\n\n\n\nHEAD\n\n\nCL\n\n\nMID\n\n\nMID\n\n\nAR\n\n\nAN\n\n\nAC1\n\n\nAC2\n\n\n\n\n\n\n\n\nComponents\n\n\n\n\nHead \n\n\nClient ID \n\n\nMessage ID \n\n\nActor ID \n\n\nAction ID \n\n\nAction Condition 1 \n\n\nAction Condition 2 \n\n\n\n\n0x04 - ActionExtended\n\n\nAn Action which will be followed by additional \nData\n or \nDataEnd\n messages. Identical in structure to \n0x00\n.\n\n\nIf an ActionExtended Message requires only one additional Data Message, that Message should be \n0x12\n \nDataEnd\n. \n0x12\n\nallows the transmission of data, but also indicates to the receiver that no more data attached to this message should be\nexpected. \n\n\nBytes\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n6\n\n\n7\n\n\n8\n\n\n9\n\n\n10\n\n\n11\n\n\n12\n\n\n13\n\n\n14\n\n\n15\n\n\n16\n\n\n17\n\n\n18\n\n\n19\n\n\n20\n\n\n21\n\n\n22\n\n\n23\n\n\n\n\n\n\n\n\n\n\nHEAD\n\n\nCL\n\n\nCL\n\n\nCL\n\n\nMID\n\n\nMID\n\n\nMID\n\n\nMID\n\n\nAR\n\n\nAR\n\n\nAR\n\n\nAR\n\n\nAN\n\n\nAN\n\n\nAN\n\n\nAN\n\n\nAC1\n\n\nAC1\n\n\nAC1\n\n\nAC1\n\n\nAC2\n\n\nAC2\n\n\nAC2\n\n\nAC2\n\n\n\n\n\n\n\n\nComponents\n\n\n\n\nHead \n\n\nClient ID \n\n\nMessage ID \n\n\nActor ID \n\n\nAction ID \n\n\nAction Condition 1 \n\n\nAction Condition 2  \n\n\n\n\n0x0E - Data\n\n\nData attached to an \nActionExtended\n Message. Data Messages should not be sent without a preceding ActionExtended \nMessage. If the transfer of such 'orphaned' data is required, use \n0x10\n - \nRaw Data\n.\n\n\nThe Data message is \nn + 11\n bytes long, where \nn\n = the size of the data attached. Attached data is limited to 255 bytes.\n\n\nBytes\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n6\n\n\n7\n\n\n8\n\n\n9\n\n\n10\n\n\n11\n\n\n12\n\n\n13\n\n\n...\n\n\nn\n\n\n\n\n\n\n\n\n\n\nHEAD\n\n\nCL\n\n\nCL\n\n\nCL\n\n\nMID\n\n\nMID\n\n\nMID\n\n\nMID\n\n\nPMSG\n\n\nPMSG\n\n\nPMSG\n\n\nPMSG\n\n\nSIZ\n\n\nDAT\n\n\nDAT\n\n\nDAT\n\n\n\n\n\n\n\n\nComponents\n\n\n\n\nHead\n\n\nClient ID\n\n\nMessage ID\n\n\nParent Message\n\n\nSize\n\n\nData\n\n\n\n\n0x12 - DataEnd\n\n\nIdentical in structure to \n0x0E\n - \nData\n. However, this Message Type indicates that this is the final Data Message\nattached to its associated Parent Message. Therefore, every \n0x04\n \nActionExtended\n Message should be followed by any \nnumber of \n0x0E\n \nData\n Messages, and exactly one \n0x12\n \nDataEnd\n Message.\n\n\nBytes\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n6\n\n\n7\n\n\n8\n\n\n9\n\n\n10\n\n\n11\n\n\n12\n\n\n13\n\n\n...\n\n\nn\n\n\n\n\n\n\n\n\n\n\nHEAD\n\n\nCL\n\n\nCL\n\n\nCL\n\n\nMID\n\n\nMID\n\n\nMID\n\n\nMID\n\n\nPMSG\n\n\nPMSG\n\n\nPMSG\n\n\nPMSG\n\n\nSIZ\n\n\nDAT\n\n\nDAT\n\n\nDAT\n\n\n\n\n\n\n\n\nComponents\n\n\n\n\nHead\n\n\nClient ID\n\n\nMessage ID\n\n\nParent Message\n\n\nSize\n\n\nData\n\n\n\n\n0x14 - ActionData\n\n\nAn Action with a self-contained Data Message. \n\n\nThis message acts as the combination of an \nActionExt\n Message and a \nData\n Message. It contains an initial stream of \ndata, and more importantly, signifies that the receiver should expect additional \nData\n and \nDataEnd\n messages.\n\n\nBytes\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n6\n\n\n7\n\n\n8\n\n\n9\n\n\n10\n\n\n11\n\n\n12\n\n\n13\n\n\n14\n\n\n15\n\n\n16\n\n\n17\n\n\n18\n\n\n19\n\n\n20\n\n\n21\n\n\n22\n\n\n23\n\n\n24\n\n\n25\n\n\n...\n\n\nn\n\n\n\n\n\n\n\n\n\n\nHEAD\n\n\nCL\n\n\nCL\n\n\nCL\n\n\nMID\n\n\nMID\n\n\nMID\n\n\nMID\n\n\nAR\n\n\nAR\n\n\nAR\n\n\nAR\n\n\nAN\n\n\nAN\n\n\nAN\n\n\nAN\n\n\nAC1\n\n\nAC1\n\n\nAC1\n\n\nAC1\n\n\nAC2\n\n\nAC2\n\n\nAC2\n\n\nAC2\n\n\nSIZ\n\n\nDAT\n\n\nDAT\n\n\nDAT\n\n\n\n\n\n\n\n\nComponents\n\n\n\n\nHead \n\n\nClient ID \n\n\nMessage ID \n\n\nActor ID \n\n\nAction ID \n\n\nAction Condition 1 \n\n\nAction Condition 2  \n\n\n\n\n0x16 - ActionDataEnd\n\n\nAn Action with a self-contained Data Message. \n\n\nThis message acts as the combination of an \nActionExt\n Message and a \nDataEnd\n Message. Unlike \nActionData\n, this \nmessage is entirely self-contained, and does not imply additional attached \nData\n or \nDataEnd\n messages.\n\n\nBytes\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n6\n\n\n7\n\n\n8\n\n\n9\n\n\n10\n\n\n11\n\n\n12\n\n\n13\n\n\n14\n\n\n15\n\n\n16\n\n\n17\n\n\n18\n\n\n19\n\n\n20\n\n\n21\n\n\n22\n\n\n23\n\n\n24\n\n\n25\n\n\n...\n\n\nn\n\n\n\n\n\n\n\n\n\n\nHEAD\n\n\nCL\n\n\nCL\n\n\nCL\n\n\nMID\n\n\nMID\n\n\nMID\n\n\nMID\n\n\nAR\n\n\nAR\n\n\nAR\n\n\nAR\n\n\nAN\n\n\nAN\n\n\nAN\n\n\nAN\n\n\nAC1\n\n\nAC1\n\n\nAC1\n\n\nAC1\n\n\nAC2\n\n\nAC2\n\n\nAC2\n\n\nAC2\n\n\nSIZ\n\n\nDAT\n\n\nDAT\n\n\nDAT\n\n\n\n\n\n\n\n\nComponents\n\n\n\n\nHead \n\n\nClient ID \n\n\nMessage ID \n\n\nActor ID \n\n\nAction ID \n\n\nAction Condition 1 \n\n\nAction Condition 2  \n\n\n\n\n0x18 - ArbData\n\n\nA Data Message with arbitrarily structured Data components. These Data components are preceded by a Size component and a\nDataType component which tells the recipient how to decode them.\n\n\nBytes\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n6\n\n\n7\n\n\n8\n\n\n9\n\n\n10\n\n\n11\n\n\n...\n\n\n...\n\n\n...\n\n\n...\n\n\n...\n\n\n...\n\n\nn\n\n\n\n\n\n\n\n\n\n\nHEAD\n\n\nCL\n\n\nCL\n\n\nCL\n\n\nMID\n\n\nMID\n\n\nMID\n\n\nMID\n\n\nNUM\n\n\nSIZ\n\n\nTYP\n\n\nDAT\n\n\n...\n\n\nSIZ\n\n\nTYP\n\n\nDAT\n\n\nDAT\n\n\n...\n\n\nDAT\n\n\n\n\n\n\n\n\nComponents\n\n\n\n\nHead \n\n\nClient ID \n\n\nMessage ID \n\n\nData Component Count\n\n\nData Size\n\n\nData\n\n\n\n\n0xF0 - 0xFF: Protocol State Message Types\n\n\nThese Messages communicate information about the state of the client, server, and connection.\n\n\n0xFF - Ack\n\n\nAcknowledges the receipt of any Message which requires it. PMSG is the Message ID of the Message requiring Ack. Ack \n messages never require further Acks. See \nAck Behavior\n for details on GGMP's Ack behavior.\n\n\nBytes\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n6\n\n\n7\n\n\n\n\n\n\n\n\n\n\nHEAD\n\n\nCL\n\n\nCL\n\n\nCL\n\n\nPMSG\n\n\nPMSG\n\n\nPMSG\n\n\nPMSG\n\n\n\n\n\n\n\n\nComponents\n\n\n\n\nHead\n\n\nClient ID\n\n\nParent Message", 
            "title": "Message Types"
        }, 
        {
            "location": "/message-types/#message-types", 
            "text": "GGMP provides a number of various  Message Types  for a variety of use cases related to game client and server\n programming. Many of these types are designed to be as flexible as possible. GGMP stands for  Generic  Gameserver \n Messaging Protocol, after all. It's up to you, the game developer to determine what Actor 45 is, what Actions he can \n take, and what to do with all that information. Is it critical that the server receive your data? Use an  Ack  variant\n of your Message and your client library will ensure it's received. Don't need support for over 4 billion actors? Use \n  ActionShort  Messages for your game instead.", 
            "title": "Message Types"
        }, 
        {
            "location": "/message-types/#req-ack-vs-no-ack", 
            "text": "Message Types ranging from 0x00 to 0xEF have both Req-Ack and No-Ack variants. For the sake of conciseness and brevity, only\ntheir Req-Ack variants are listed here. However, since Req-Ack vs. No-Ack doesn't change the structure of a message, converting\nbetween them is easy: Simply increment the Header by 0x01, and you have the No-Ack version of that message. For example, the \nHeader value for  Action, Req-Ack  is 0x00. The corresponding Header for  Action, No-Ack  is 0x01.   In this documentation, we will explicitly denote  No-Ack  when referring to such a variant. If no variant is specified, \nit can safely be inferred that the Message in question is  Req-Ack .", 
            "title": "Req-Ack vs. No-Ack"
        }, 
        {
            "location": "/message-types/#0x00-0xef-game-state-message-types", 
            "text": "These Message Types make up the core of communication over GGMP.", 
            "title": "0x00 - 0xEF: Game State Message Types"
        }, 
        {
            "location": "/message-types/#0x00-action", 
            "text": "The bread-and-butter message of GGMP, a game Action with Actors and Conditions.  Bytes     0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23      HEAD  CL  CL  CL  MID  MID  MID  MID  AR  AR  AR  AR  AN  AN  AN  AN  AC1  AC1  AC1  AC1  AC2  AC2  AC2  AC2     Components   Head   Client ID   Message ID   Actor ID   Action ID   Action Condition 1   Action Condition 2", 
            "title": "0x00 - Action"
        }, 
        {
            "location": "/message-types/#0x02-actionshort", 
            "text": "A micro-sized version of an Action. Ideal for demos, tutorials, and ultra-lightweight games.  Bytes     0  1  2  3  4  5  6  7      HEAD  CL  MID  MID  AR  AN  AC1  AC2     Components   Head   Client ID   Message ID   Actor ID   Action ID   Action Condition 1   Action Condition 2", 
            "title": "0x02 - ActionShort"
        }, 
        {
            "location": "/message-types/#0x04-actionextended", 
            "text": "An Action which will be followed by additional  Data  or  DataEnd  messages. Identical in structure to  0x00 .  If an ActionExtended Message requires only one additional Data Message, that Message should be  0x12   DataEnd .  0x12 \nallows the transmission of data, but also indicates to the receiver that no more data attached to this message should be\nexpected.   Bytes     0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23      HEAD  CL  CL  CL  MID  MID  MID  MID  AR  AR  AR  AR  AN  AN  AN  AN  AC1  AC1  AC1  AC1  AC2  AC2  AC2  AC2     Components   Head   Client ID   Message ID   Actor ID   Action ID   Action Condition 1   Action Condition 2", 
            "title": "0x04 - ActionExtended"
        }, 
        {
            "location": "/message-types/#0x0e-data", 
            "text": "Data attached to an  ActionExtended  Message. Data Messages should not be sent without a preceding ActionExtended \nMessage. If the transfer of such 'orphaned' data is required, use  0x10  -  Raw Data .  The Data message is  n + 11  bytes long, where  n  = the size of the data attached. Attached data is limited to 255 bytes.  Bytes     0  1  2  3  4  5  6  7  8  9  10  11  12  13  ...  n      HEAD  CL  CL  CL  MID  MID  MID  MID  PMSG  PMSG  PMSG  PMSG  SIZ  DAT  DAT  DAT     Components   Head  Client ID  Message ID  Parent Message  Size  Data", 
            "title": "0x0E - Data"
        }, 
        {
            "location": "/message-types/#0x12-dataend", 
            "text": "Identical in structure to  0x0E  -  Data . However, this Message Type indicates that this is the final Data Message\nattached to its associated Parent Message. Therefore, every  0x04   ActionExtended  Message should be followed by any \nnumber of  0x0E   Data  Messages, and exactly one  0x12   DataEnd  Message.  Bytes     0  1  2  3  4  5  6  7  8  9  10  11  12  13  ...  n      HEAD  CL  CL  CL  MID  MID  MID  MID  PMSG  PMSG  PMSG  PMSG  SIZ  DAT  DAT  DAT     Components   Head  Client ID  Message ID  Parent Message  Size  Data", 
            "title": "0x12 - DataEnd"
        }, 
        {
            "location": "/message-types/#0x14-actiondata", 
            "text": "An Action with a self-contained Data Message.   This message acts as the combination of an  ActionExt  Message and a  Data  Message. It contains an initial stream of \ndata, and more importantly, signifies that the receiver should expect additional  Data  and  DataEnd  messages.  Bytes     0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  ...  n      HEAD  CL  CL  CL  MID  MID  MID  MID  AR  AR  AR  AR  AN  AN  AN  AN  AC1  AC1  AC1  AC1  AC2  AC2  AC2  AC2  SIZ  DAT  DAT  DAT     Components   Head   Client ID   Message ID   Actor ID   Action ID   Action Condition 1   Action Condition 2", 
            "title": "0x14 - ActionData"
        }, 
        {
            "location": "/message-types/#0x16-actiondataend", 
            "text": "An Action with a self-contained Data Message.   This message acts as the combination of an  ActionExt  Message and a  DataEnd  Message. Unlike  ActionData , this \nmessage is entirely self-contained, and does not imply additional attached  Data  or  DataEnd  messages.  Bytes     0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  ...  n      HEAD  CL  CL  CL  MID  MID  MID  MID  AR  AR  AR  AR  AN  AN  AN  AN  AC1  AC1  AC1  AC1  AC2  AC2  AC2  AC2  SIZ  DAT  DAT  DAT     Components   Head   Client ID   Message ID   Actor ID   Action ID   Action Condition 1   Action Condition 2", 
            "title": "0x16 - ActionDataEnd"
        }, 
        {
            "location": "/message-types/#0x18-arbdata", 
            "text": "A Data Message with arbitrarily structured Data components. These Data components are preceded by a Size component and a\nDataType component which tells the recipient how to decode them.  Bytes     0  1  2  3  4  5  6  7  8  9  10  11  ...  ...  ...  ...  ...  ...  n      HEAD  CL  CL  CL  MID  MID  MID  MID  NUM  SIZ  TYP  DAT  ...  SIZ  TYP  DAT  DAT  ...  DAT     Components   Head   Client ID   Message ID   Data Component Count  Data Size  Data", 
            "title": "0x18 - ArbData"
        }, 
        {
            "location": "/message-types/#0xf0-0xff-protocol-state-message-types", 
            "text": "These Messages communicate information about the state of the client, server, and connection.", 
            "title": "0xF0 - 0xFF: Protocol State Message Types"
        }, 
        {
            "location": "/message-types/#0xff-ack", 
            "text": "Acknowledges the receipt of any Message which requires it. PMSG is the Message ID of the Message requiring Ack. Ack \n messages never require further Acks. See  Ack Behavior  for details on GGMP's Ack behavior.  Bytes     0  1  2  3  4  5  6  7      HEAD  CL  CL  CL  PMSG  PMSG  PMSG  PMSG     Components   Head  Client ID  Parent Message", 
            "title": "0xFF - Ack"
        }, 
        {
            "location": "/ack-behavior/", 
            "text": "Acknowledgement Behavior\n\n\nThe Ack message is perhaps the most important of the Message Types in GGMP. It is used in situations where a client or \nserver must know that the other end has received their message; e.g., any situation in which the game state risks \nbecoming desynchronized between the two parties. Consider the following example.\n\n\nNote: All discussions in this article assume ReqAck variants when discussing a \nMessageType\n. \n\n\nHEAD 0x05   Action Extended Req Ack\n...\nAR   0x0001 Player 1 Entity Model\nAN   0x003F Move Along Vector\nAC1  0x0000 None\n...\n\nHEAD 0x13   Data End Req Ack\n...\nDAT  0xF3.. \nVector Definition\n\n\nEAD 0x05   Action Extended Req Ack\n...\nAR   0x0001 Player 1 Entity Model\nAN   0x003F Move Along Vector\nAC1  0x0000 None\n...\n\nHEAD 0x13   Data End Req Ack\n...\nDAT  0xF4.. \nNew Vector Definition\n\n\n\n\n\nBoth message sets require acknowledgment, but to what degree? If the initial \nActionExt\n message is never acknowledged, \ndoes it make sense to send its \nDataEnd\n message? Additionally, what happens if one message pair gets received before\nthe other? \n\n\nNow consider this example\n\n\nHEAD 0x01   Action Req Ack\n...\nAR   0x0001 Player 1 Entity Model\nAN   0x0030 Move to Position\nAC1  0xFD07 \nPosition Definition\n\nAC2  0xE9C0 \nPosition Definition\n\n...\n\nHEAD 0x01   Action Req Ack\n...\nAR   0x0001 Player 1 Entity Model\nAN   0x0030 Move to Position\nAC1  0xFD1F \nNew Position Definition\n\nAC2  0xEA06 \nNew Position Definition\n\n...\n\n\n\n\n\nIn this case, once again, both messages require acknowledgement. However, in this case, what happens if only the first\nmessage is dropped? Only the second?\n\n\nAll of these questions can be handled with knowledge of the implementation, but GGMP is intended to be implementation \nagnostic. Even though the first example is communicating events, there are many valid and appealing reasons to\nchoose the second example, which communicates state. \n\n\nIn the first example, it is critical that \nboth\n sets of messages get received, and ideally, in order. Even though \nvector addition is commutative, one set of movements may trace the player model through a nonsensical path. In the\nsecond example, it might be critical that only the most recent movement get acknowledged\n1\n.\n\n\nGGMP defines only one rule for acknowledgment of messages.\n\n\nMandatory Ack Behavior\n\n\nSenders implementing GGMP must respond to every \nReqAck\n message with an \nAck\n message. Receivers implementing GGMP\nmust resend unacknowledged messages if they have not received an \nAck\n for that message within #TIMEOUT\n\n2\n ms. If the message remains unacknowledged, this process should be repeated 2 \nmore times, each time incrementing #TIMEOUT by an additional #TIMEOUT ms. \n\n\n#TIMEOUT = 30ms\nSender                      Receiver\n|                                  |\n| --- MID 0x0021, ReqAck --------\n |   \n| ...30ms...                       |\n| --- MID 0x0021, ReqAck --------\n |\n| ...60ms...                       |\n| --- MID 0x0021, ReqAck --------\n |\n| ...90ms...                       |\n| --- MID 0x0021, ReqAck --------\n |\n|\n\n\n\n\nIf any message sent is not properly acknowledged by this point, the message is considered \nlost\n. A lost message\nmust not be sent with the same Message ID, however it may be re-sent with a new Message ID. \nThe Protocol does not explicitly define behavior beyond this point. However, the GGMP Libraries provided by the GGMP \nContributors will offer some advanced functionality. Possible implementations include automatically re-sending messages, \nraising exceptions, or variable behavior depending on Message Type or Action ID.\n\n\nAck Behavior in the GGMP Language Libraries\n\n\nOne of the strengths in the GGMP is the availability of client and server libraries for a variety of languages that will\nmake its implementation near effortless. In designing the protocol, we attempt to keep decisions for the protocol separate\nfrom the decisions for the libraries. However, more often than not, one informs the other, and here we'll discuss the \ndesired behavior for the official language libraries.\n\n\nHandling Lost Messages\n\n\nCurrently, a GGMP language library maintains 4 queues:\n\n\n\n\ninbox\n, for Messages that have been received and are awaiting processing by the game itself\n\n\noutbox\n, for Messages that have been built and will be sent on the next call of \nsendAll()\n (or similar)\n\n\nawaitbox\n, for \nReqAck\n Messages that have been sent but not Acked\n\n\nlostbox\n, for lost Messages\n\n\n\n\nWe intend to offer programmers at least the following options regarding lost messages:\n\n\n\n\nAuto Resend: Automatically rebuild Messages from \nlostbox\n and resend them\n\n\nManualProcessing: Require the programmer to read from \nlostbox\n in order to determine how to handle side effects of a dropped message\n\n\n\n\nAdditionally, we may implement a \"burst fire\" mode, where messages are sent in groups of 3 or more between the #TIMEOUT periods, \n in order to increase chance of receipt.\n\n\nFootnotes\n\n\n\n\nThere are many valid situations where it's also critical that all state-based movement messages get received as well.\n\n\n#TIMEOUT has yet to be defined.", 
            "title": "Ack Behavior"
        }, 
        {
            "location": "/ack-behavior/#acknowledgement-behavior", 
            "text": "The Ack message is perhaps the most important of the Message Types in GGMP. It is used in situations where a client or \nserver must know that the other end has received their message; e.g., any situation in which the game state risks \nbecoming desynchronized between the two parties. Consider the following example.  Note: All discussions in this article assume ReqAck variants when discussing a  MessageType .   HEAD 0x05   Action Extended Req Ack\n...\nAR   0x0001 Player 1 Entity Model\nAN   0x003F Move Along Vector\nAC1  0x0000 None\n...\n\nHEAD 0x13   Data End Req Ack\n...\nDAT  0xF3..  Vector Definition \n\nEAD 0x05   Action Extended Req Ack\n...\nAR   0x0001 Player 1 Entity Model\nAN   0x003F Move Along Vector\nAC1  0x0000 None\n...\n\nHEAD 0x13   Data End Req Ack\n...\nDAT  0xF4..  New Vector Definition   Both message sets require acknowledgment, but to what degree? If the initial  ActionExt  message is never acknowledged, \ndoes it make sense to send its  DataEnd  message? Additionally, what happens if one message pair gets received before\nthe other?   Now consider this example  HEAD 0x01   Action Req Ack\n...\nAR   0x0001 Player 1 Entity Model\nAN   0x0030 Move to Position\nAC1  0xFD07  Position Definition \nAC2  0xE9C0  Position Definition \n...\n\nHEAD 0x01   Action Req Ack\n...\nAR   0x0001 Player 1 Entity Model\nAN   0x0030 Move to Position\nAC1  0xFD1F  New Position Definition \nAC2  0xEA06  New Position Definition \n...  In this case, once again, both messages require acknowledgement. However, in this case, what happens if only the first\nmessage is dropped? Only the second?  All of these questions can be handled with knowledge of the implementation, but GGMP is intended to be implementation \nagnostic. Even though the first example is communicating events, there are many valid and appealing reasons to\nchoose the second example, which communicates state.   In the first example, it is critical that  both  sets of messages get received, and ideally, in order. Even though \nvector addition is commutative, one set of movements may trace the player model through a nonsensical path. In the\nsecond example, it might be critical that only the most recent movement get acknowledged 1 .  GGMP defines only one rule for acknowledgment of messages.", 
            "title": "Acknowledgement Behavior"
        }, 
        {
            "location": "/ack-behavior/#mandatory-ack-behavior", 
            "text": "Senders implementing GGMP must respond to every  ReqAck  message with an  Ack  message. Receivers implementing GGMP\nmust resend unacknowledged messages if they have not received an  Ack  for that message within #TIMEOUT 2  ms. If the message remains unacknowledged, this process should be repeated 2 \nmore times, each time incrementing #TIMEOUT by an additional #TIMEOUT ms.   #TIMEOUT = 30ms\nSender                      Receiver\n|                                  |\n| --- MID 0x0021, ReqAck --------  |   \n| ...30ms...                       |\n| --- MID 0x0021, ReqAck --------  |\n| ...60ms...                       |\n| --- MID 0x0021, ReqAck --------  |\n| ...90ms...                       |\n| --- MID 0x0021, ReqAck --------  |\n|  If any message sent is not properly acknowledged by this point, the message is considered  lost . A lost message\nmust not be sent with the same Message ID, however it may be re-sent with a new Message ID. \nThe Protocol does not explicitly define behavior beyond this point. However, the GGMP Libraries provided by the GGMP \nContributors will offer some advanced functionality. Possible implementations include automatically re-sending messages, \nraising exceptions, or variable behavior depending on Message Type or Action ID.", 
            "title": "Mandatory Ack Behavior"
        }, 
        {
            "location": "/ack-behavior/#ack-behavior-in-the-ggmp-language-libraries", 
            "text": "One of the strengths in the GGMP is the availability of client and server libraries for a variety of languages that will\nmake its implementation near effortless. In designing the protocol, we attempt to keep decisions for the protocol separate\nfrom the decisions for the libraries. However, more often than not, one informs the other, and here we'll discuss the \ndesired behavior for the official language libraries.  Handling Lost Messages  Currently, a GGMP language library maintains 4 queues:   inbox , for Messages that have been received and are awaiting processing by the game itself  outbox , for Messages that have been built and will be sent on the next call of  sendAll()  (or similar)  awaitbox , for  ReqAck  Messages that have been sent but not Acked  lostbox , for lost Messages   We intend to offer programmers at least the following options regarding lost messages:   Auto Resend: Automatically rebuild Messages from  lostbox  and resend them  ManualProcessing: Require the programmer to read from  lostbox  in order to determine how to handle side effects of a dropped message   Additionally, we may implement a \"burst fire\" mode, where messages are sent in groups of 3 or more between the #TIMEOUT periods, \n in order to increase chance of receipt.", 
            "title": "Ack Behavior in the GGMP Language Libraries"
        }, 
        {
            "location": "/ack-behavior/#footnotes", 
            "text": "There are many valid situations where it's also critical that all state-based movement messages get received as well.  #TIMEOUT has yet to be defined.", 
            "title": "Footnotes"
        }, 
        {
            "location": "/techspecs/", 
            "text": "Technical Specifications\n\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL\n      NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and\n      \"OPTIONAL\" in this document are to be interpreted as described in\n      \nRFC 2119\n.\n\n\nNetworking\n\n\nGGMP MUST use UDP port 12358.\n\n\nComponents\n\n\nThe following components MUST be decoded as \n32-bit unsigned integers.\n \n\n\n\n\nClient ID (CL)\n\n\nMessage ID (MID)\n\n\nActor ID (AR)\n\n\nAction ID (AN)\n\n\nAction Condition 1 (AC1)\n\n\nAction Condition 2 (AC2)\n\n\n\n\nThe following components MUST be decoded as \n8-bit unsigned integers.\n\n\n\n\nHeader (HEAD)\n\n\nSize (SIZ)\n\n\n\n\nThe following components MUST be provided by language libraries as an \niterable stream of bytes\n. Decoding into such\n a format SHOULD use one of that language's built-in types. Decoding them is left to the implementation.\n\n\n\n\nData (DAT)", 
            "title": "Technical Specifications"
        }, 
        {
            "location": "/techspecs/#technical-specifications", 
            "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL\n      NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and\n      \"OPTIONAL\" in this document are to be interpreted as described in\n       RFC 2119 .", 
            "title": "Technical Specifications"
        }, 
        {
            "location": "/techspecs/#networking", 
            "text": "GGMP MUST use UDP port 12358.", 
            "title": "Networking"
        }, 
        {
            "location": "/techspecs/#components", 
            "text": "The following components MUST be decoded as  32-bit unsigned integers.     Client ID (CL)  Message ID (MID)  Actor ID (AR)  Action ID (AN)  Action Condition 1 (AC1)  Action Condition 2 (AC2)   The following components MUST be decoded as  8-bit unsigned integers.   Header (HEAD)  Size (SIZ)   The following components MUST be provided by language libraries as an  iterable stream of bytes . Decoding into such\n a format SHOULD use one of that language's built-in types. Decoding them is left to the implementation.   Data (DAT)", 
            "title": "Components"
        }, 
        {
            "location": "/CHANGELOG/", 
            "text": "CHANGELOG\n\n\nFuture\n\n\n\n\n[PROTOCOL:MESSAGES]\n Refactor \nData\n behavior, consider one universal \nDataEnd\n message?\n\n\n[PROTOCOL:MESSAGES]\n Do \nActionExt\n or \nActionShort\n have a place anymore?\n\n\n[PROTOCOL:COMMUNICATION]\n Suggested \"burst fire\" mechanism of sending messages.\n\n\n\n\nv0.3.0\n\n\n\n\n[PROTOCOL:COMMUNICATION, LIBRARIES:COMMUNICATION]\n Modified Ack requirements, mandating certain behaviors from language libraries.  \n\n\n\n\nv0.2.0\n\n\n\n\n[PROTOCOL:MESSAGES]\n Made requiring acknowledgment the default behavior for all message types. \n\n\n[PROTOCOL:MESSAGES]\n Made Message ID use mandatory\n\n\n[PROTOCOL:MESSAGES]\n Added new \nActionData\n message type, which acts as a combination of \nAction\n and \nDataEnd\n\n\n[PROTOCOL:MESSAGES]\n Reversed byte ordering to a sensible arrangement. The Header should refer to the first byte sent\nand received, and so forth.\n\n\n[PROTOCOL:MESSAGES]\n Extended the size of all non-head components to 4 bytes for ease of message parsing, except\n\nActionShort\n messages.\n\n\n\n\nv0.1.0\n\n\n\n\n[PROTOCOL:GENERAL]\n Initial versioning, following Semantic Versioning practices.\n\n\n[DOC]\n Added changelog.", 
            "title": "CHANGELOG"
        }, 
        {
            "location": "/CHANGELOG/#changelog", 
            "text": "", 
            "title": "CHANGELOG"
        }, 
        {
            "location": "/CHANGELOG/#future", 
            "text": "[PROTOCOL:MESSAGES]  Refactor  Data  behavior, consider one universal  DataEnd  message?  [PROTOCOL:MESSAGES]  Do  ActionExt  or  ActionShort  have a place anymore?  [PROTOCOL:COMMUNICATION]  Suggested \"burst fire\" mechanism of sending messages.", 
            "title": "Future"
        }, 
        {
            "location": "/CHANGELOG/#v030", 
            "text": "[PROTOCOL:COMMUNICATION, LIBRARIES:COMMUNICATION]  Modified Ack requirements, mandating certain behaviors from language libraries.", 
            "title": "v0.3.0"
        }, 
        {
            "location": "/CHANGELOG/#v020", 
            "text": "[PROTOCOL:MESSAGES]  Made requiring acknowledgment the default behavior for all message types.   [PROTOCOL:MESSAGES]  Made Message ID use mandatory  [PROTOCOL:MESSAGES]  Added new  ActionData  message type, which acts as a combination of  Action  and  DataEnd  [PROTOCOL:MESSAGES]  Reversed byte ordering to a sensible arrangement. The Header should refer to the first byte sent\nand received, and so forth.  [PROTOCOL:MESSAGES]  Extended the size of all non-head components to 4 bytes for ease of message parsing, except ActionShort  messages.", 
            "title": "v0.2.0"
        }, 
        {
            "location": "/CHANGELOG/#v010", 
            "text": "[PROTOCOL:GENERAL]  Initial versioning, following Semantic Versioning practices.  [DOC]  Added changelog.", 
            "title": "v0.1.0"
        }
    ]
}